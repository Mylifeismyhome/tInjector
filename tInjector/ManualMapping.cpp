#include "ManualMapping.h"
#include "Executor.h"

struct TShellCodeParam
{
	LPVOID pLoadLibraryA; // required to load additional libraries
	LPVOID pGetProcAddress; // required to get it's process address to fix up iat
	LPVOID pModuleAddress; // address of mapped module
	EShellCodeRet ret;
};

/*tDWORD ShellCode(LPVOID param)
{
	auto sc = (ShellCode_t*)param;

	typedef HMODULE(WINAPI* tLoadLibraryA)(LPCSTR lpLibFileName);
	auto fncLoadLibraryA = (tLoadLibraryA)sc->pLoadLibraryA;

	typedef FARPROC(WINAPI* tGetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
	auto fncGetProcAddress = (tGetProcAddress)sc->pGetProcAddress;

	tDWORD* moduleBase = reinterpret_cast<tDWORD*>(sc->pModuleAddress);

	auto header = reinterpret_cast<PIMAGE_DOS_HEADER>(moduleBase);
	auto ntheader = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<tDWORD>(moduleBase) + header->e_lfanew);

	// reloc
	tDWORD* locationDelta = reinterpret_cast<tDWORD*>(reinterpret_cast<tDWORD>(moduleBase) - ntheader->OptionalHeader.ImageBase);
	if (locationDelta) {
		auto directoryReloc = ntheader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
		if (directoryReloc.Size != 0) {
			auto* relocdata = reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<tDWORD>(moduleBase) + directoryReloc.VirtualAddress);
			const auto* relocEnd = reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<tDWORD>(relocdata) + directoryReloc.Size);

			while (relocdata < relocEnd && relocdata->SizeOfBlock) {
				UINT entryCount = (relocdata->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
				WORD* relativeInfo = reinterpret_cast<WORD*>(relocdata + 1);

				for (UINT i = 0; i != entryCount; ++i, ++relativeInfo) {
					if (!RELOC_FLAG(*relativeInfo)) {
						continue;
					}

					(*reinterpret_cast<tDWORD*>(reinterpret_cast<tDWORD>(moduleBase) + relocdata->VirtualAddress + ((*relativeInfo) & 0xFFF))) += reinterpret_cast<tDWORD>(locationDelta);
				}

				relocdata = reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<BYTE*>(relocdata) + relocdata->SizeOfBlock);
			}
		}
	}

	// import resolve
	auto directoryImport = ntheader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	if (directoryImport.Size != 0)
	{
		auto importDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(reinterpret_cast<tDWORD>(moduleBase) + directoryImport.VirtualAddress);
		while (importDescriptor && importDescriptor->Name != 0)
		{
			auto libName = reinterpret_cast<LPCSTR>(reinterpret_cast<tDWORD>(moduleBase) + importDescriptor->Name);

			// load it's required module if not done yet
			auto hModule = fncLoadLibraryA(libName);

			tDWORD* pThunkRef = reinterpret_cast<tDWORD*>(reinterpret_cast<tDWORD>(moduleBase) + importDescriptor->OriginalFirstThunk);
			tDWORD* pFuncRef = reinterpret_cast<tDWORD*>(reinterpret_cast<tDWORD>(moduleBase) + importDescriptor->FirstThunk);

			if (!pThunkRef)
			{
				pThunkRef = pFuncRef;
			}

			for (; *pThunkRef; ++pThunkRef, ++pFuncRef)
			{
				if (IMAGE_SNAP_BY_ORDINAL(*pThunkRef))
				{
					*pFuncRef = (tDWORD)fncGetProcAddress(hModule, reinterpret_cast<char*>(*pThunkRef & 0xFFFF));
				}
				else
				{
					auto* pImport = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(reinterpret_cast<tDWORD>(moduleBase) + (*pThunkRef));
					*pFuncRef = (tDWORD)fncGetProcAddress(hModule, pImport->Name);
				}
			}

			++importDescriptor;
		}
	}

	// tls callback
	auto directoryTLS = ntheader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	if (directoryTLS.Size != 0) {
		IMAGE_TLS_DIRECTORY* tls = reinterpret_cast<IMAGE_TLS_DIRECTORY*>(reinterpret_cast<tDWORD>(moduleBase) + directoryTLS.VirtualAddress);
		PIMAGE_TLS_CALLBACK* callback = reinterpret_cast<PIMAGE_TLS_CALLBACK*>(tls->AddressOfCallBacks);

		for (; callback && *callback; ++callback) {
			(*callback)(moduleBase, DLL_PROCESS_ATTACH, nullptr);
		}
	}

	// call entry point
	typedef BOOL(WINAPI* tDllMain)(HINSTANCE hinstDLL, tDWORD fdwReason, LPVOID lpvReserved);
	auto ep = reinterpret_cast<tDllMain>(reinterpret_cast<tDWORD>(moduleBase) + ntheader->OptionalHeader.AddressOfEntryPoint);
	if (!ep(reinterpret_cast<HINSTANCE>(moduleBase), DLL_PROCESS_ATTACH, nullptr))
	{
		sc->ret = EShellCodeRet::SHELLCODE_FAILED;
		return 1;
	}

	sc->ret = EShellCodeRet::SHELLCODE_SUCCESS;
	return 0;
}*/

// ByteCode Array of the 'ShellCode' function
#ifdef _WIN64
static BYTE ShellCode[] =
{
		0x48, 0x89, 0x4C, 0x24, 0x08,
		0x55,
		0x48, 0x81, 0xEC, 0x20, 0x01, 0x00, 0x00,
		0x48, 0x8D, 0x6C, 0x24, 0x20,
		0x48, 0x8B, 0x85, 0x10, 0x01, 0x00, 0x00,
		0x48, 0x89, 0x45, 0x00,
		0x48, 0x8B, 0x45, 0x00,
		0x48, 0x8B, 0x00,
		0x48, 0x89, 0x45, 0x08,
		0x48, 0x8B, 0x45, 0x00,
		0x48, 0x8B, 0x40, 0x08,
		0x48, 0x89, 0x45, 0x10,
		0x48, 0x8B, 0x45, 0x00,
		0x48, 0x8B, 0x40, 0x10,
		0x48, 0x89, 0x45, 0x18,
		0x48, 0x8B, 0x45, 0x18,
		0x48, 0x89, 0x45, 0x20,
		0x48, 0x8B, 0x45, 0x20,
		0x48, 0x63, 0x40, 0x3C,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x45, 0x28,
		0x48, 0x8B, 0x45, 0x28,
		0x48, 0x8B, 0x40, 0x30,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x2B, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x45, 0x30,
		0x48, 0x83, 0x7D, 0x30, 0x00,
		0x0F, 0x84, 0x23, 0x01, 0x00, 0x00,
		0xB8, 0x08, 0x00, 0x00, 0x00,
		0x48, 0x6B, 0xC0, 0x05,
		0x48, 0x8B, 0x4D, 0x28,
		0x48, 0x8B, 0x84, 0x01, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x89, 0x45, 0x38,
		0x83, 0x7D, 0x3C, 0x00,
		0x0F, 0x84, 0x00, 0x01, 0x00, 0x00,
		0x8B, 0x45, 0x38,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x45, 0x40,
		0x8B, 0x45, 0x3C,
		0x48, 0x8B, 0x4D, 0x40,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x45, 0x48,
		0x48, 0x8B, 0x45, 0x48,
		0x48, 0x39, 0x45, 0x40,
		0x0F, 0x83, 0xD0, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x45, 0x40,
		0x83, 0x78, 0x04, 0x00,
		0x0F, 0x84, 0xC2, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x45, 0x40,
		0x8B, 0x40, 0x04,
		0x48, 0x83, 0xE8, 0x08,
		0x33, 0xD2,
		0xB9, 0x02, 0x00, 0x00, 0x00,
		0x48, 0xF7, 0xF1,
		0x89, 0x45, 0x50,
		0x48, 0x8B, 0x45, 0x40,
		0x48, 0x83, 0xC0, 0x08,
		0x48, 0x89, 0x45, 0x58,
		0xC7, 0x45, 0x60, 0x00, 0x00, 0x00, 0x00,
		0xEB, 0x14,
		0x8B, 0x45, 0x60,
		0xFF, 0xC0,
		0x89, 0x45, 0x60,
		0x48, 0x8B, 0x45, 0x58,
		0x48, 0x83, 0xC0, 0x02,
		0x48, 0x89, 0x45, 0x58,
		0x8B, 0x45, 0x50,
		0x39, 0x45, 0x60,
		0x74, 0x5F,
		0x48, 0x8B, 0x45, 0x58,
		0x0F, 0xB7, 0x00,
		0xC1, 0xF8, 0x0C,
		0x83, 0xF8, 0x0A,
		0x74, 0x02,
		0xEB, 0xD3,
		0x48, 0x8B, 0x45, 0x40,
		0x8B, 0x00,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x8B, 0x4D, 0x58,
		0x0F, 0xB7, 0x09,
		0x81, 0xE1, 0xFF, 0x0F, 0x00, 0x00,
		0x48, 0x63, 0xC9,
		0x48, 0x8B, 0x04, 0x08,
		0x48, 0x03, 0x45, 0x30,
		0x48, 0x8B, 0x4D, 0x58,
		0x0F, 0xB7, 0x09,
		0x81, 0xE1, 0xFF, 0x0F, 0x00, 0x00,
		0x48, 0x63, 0xC9,
		0x48, 0x8B, 0x55, 0x40,
		0x8B, 0x12,
		0x4C, 0x8B, 0x45, 0x18,
		0x4C, 0x03, 0xC2,
		0x49, 0x8B, 0xD0,
		0x48, 0x89, 0x04, 0x0A,
		0xEB, 0x85,
		0x48, 0x8B, 0x45, 0x40,
		0x8B, 0x40, 0x04,
		0x48, 0x8B, 0x4D, 0x40,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x45, 0x40,
		0xE9, 0x22, 0xFF, 0xFF, 0xFF,
		0xB8, 0x08, 0x00, 0x00, 0x00,
		0x48, 0x6B, 0xC0, 0x01,
		0x48, 0x8B, 0x4D, 0x28,
		0x48, 0x8B, 0x84, 0x01, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x89, 0x45, 0x68,
		0x83, 0x7D, 0x6C, 0x00,
		0x0F, 0x84, 0x63, 0x01, 0x00, 0x00,
		0x8B, 0x45, 0x68,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x45, 0x70,
		0x48, 0x83, 0x7D, 0x70, 0x00,
		0x0F, 0x84, 0x47, 0x01, 0x00, 0x00,
		0x48, 0x8B, 0x45, 0x70,
		0x83, 0x78, 0x0C, 0x00,
		0x0F, 0x84, 0x39, 0x01, 0x00, 0x00,
		0x48, 0x8B, 0x45, 0x70,
		0x8B, 0x40, 0x0C,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x45, 0x78,
		0x48, 0x8B, 0x4D, 0x78,
		0xFF, 0x55, 0x08,
		0x48, 0x89, 0x85, 0x80, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x45, 0x70,
		0x8B, 0x00,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x85, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x45, 0x70,
		0x8B, 0x40, 0x10,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x85, 0x90, 0x00, 0x00, 0x00,
		0x48, 0x83, 0xBD, 0x88, 0x00, 0x00, 0x00, 0x00,
		0x75, 0x0E,
		0x48, 0x8B, 0x85, 0x90, 0x00, 0x00, 0x00,
		0x48, 0x89, 0x85, 0x88, 0x00, 0x00, 0x00,
		0xEB, 0x24,
		0x48, 0x8B, 0x85, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x83, 0xC0, 0x08,
		0x48, 0x89, 0x85, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x85, 0x90, 0x00, 0x00, 0x00,
		0x48, 0x83, 0xC0, 0x08,
		0x48, 0x89, 0x85, 0x90, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x85, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x83, 0x38, 0x00,
		0x0F, 0x84, 0x87, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x85, 0x88, 0x00, 0x00, 0x00,
		0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
		0x48, 0x8B, 0x00,
		0x48, 0x23, 0xC1,
		0x48, 0x85, 0xC0,
		0x74, 0x29,
		0x48, 0x8B, 0x85, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x00,
		0x48, 0x25, 0xFF, 0xFF, 0x00, 0x00,
		0x48, 0x8B, 0xD0,
		0x48, 0x8B, 0x8D, 0x80, 0x00, 0x00, 0x00,
		0xFF, 0x55, 0x10,
		0x48, 0x8B, 0x8D, 0x90, 0x00, 0x00, 0x00,
		0x48, 0x89, 0x01,
		0xEB, 0x3D,
		0x48, 0x8B, 0x85, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x00,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x85, 0x98, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x85, 0x98, 0x00, 0x00, 0x00,
		0x48, 0x83, 0xC0, 0x02,
		0x48, 0x8B, 0xD0,
		0x48, 0x8B, 0x8D, 0x80, 0x00, 0x00, 0x00,
		0xFF, 0x55, 0x10,
		0x48, 0x8B, 0x8D, 0x90, 0x00, 0x00, 0x00,
		0x48, 0x89, 0x01,
		0xE9, 0x44, 0xFF, 0xFF, 0xFF,
		0x48, 0x8B, 0x45, 0x70,
		0x48, 0x83, 0xC0, 0x14,
		0x48, 0x89, 0x45, 0x70,
		0xE9, 0xAE, 0xFE, 0xFF, 0xFF,
		0xB8, 0x08, 0x00, 0x00, 0x00,
		0x48, 0x6B, 0xC0, 0x01,
		0x48, 0x8B, 0x4D, 0x28,
		0x48, 0x8B, 0x84, 0x01, 0x88, 0x00, 0x00, 0x00,
		0x48, 0x89, 0x85, 0xA0, 0x00, 0x00, 0x00,
		0x83, 0xBD, 0xA4, 0x00, 0x00, 0x00, 0x00,
		0x74, 0x6B,
		0x8B, 0x85, 0xA0, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x85, 0xA8, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x85, 0xA8, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x40, 0x18,
		0x48, 0x89, 0x85, 0xB0, 0x00, 0x00, 0x00,
		0xEB, 0x12,
		0x48, 0x8B, 0x85, 0xB0, 0x00, 0x00, 0x00,
		0x48, 0x83, 0xC0, 0x08,
		0x48, 0x89, 0x85, 0xB0, 0x00, 0x00, 0x00,
		0x48, 0x83, 0xBD, 0xB0, 0x00, 0x00, 0x00, 0x00,
		0x74, 0x24,
		0x48, 0x8B, 0x85, 0xB0, 0x00, 0x00, 0x00,
		0x48, 0x83, 0x38, 0x00,
		0x74, 0x17,
		0x45, 0x33, 0xC0,
		0xBA, 0x01, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x8B, 0x85, 0xB0, 0x00, 0x00, 0x00,
		0xFF, 0x10,
		0xEB, 0xC0,
		0x48, 0x8B, 0x45, 0x28,
		0x8B, 0x40, 0x28,
		0x48, 0x8B, 0x4D, 0x18,
		0x48, 0x03, 0xC8,
		0x48, 0x8B, 0xC1,
		0x48, 0x89, 0x85, 0xB8, 0x00, 0x00, 0x00,
		0x45, 0x33, 0xC0,
		0xBA, 0x01, 0x00, 0x00, 0x00,
		0x48, 0x8B, 0x4D, 0x18,
		0xFF, 0x95, 0xB8, 0x00, 0x00, 0x00,
		0x85, 0xC0,
		0x75, 0x12,
		0x48, 0x8B, 0x45, 0x00,
		0xC7, 0x40, 0x18, 0x02, 0x00, 0x00, 0x00,
		0xB8, 0x01, 0x00, 0x00, 0x00,
		0xEB, 0x0D,
		0x48, 0x8B, 0x45, 0x00,
		0xC7, 0x40, 0x18, 0x01, 0x00, 0x00, 0x00,
		0x33, 0xC0,
		0x48, 0x8D, 0xA5, 0x00, 0x01, 0x00, 0x00,
		0x5D,
		0xC3
};
#else
static BYTE ShellCode[] = {
		0x55,
		0x8B, 0xEC,
		0x83, 0xEC, 0x6C,
		0x56,
		0x8B, 0x45, 0x08,
		0x89, 0x45, 0xDC,
		0x8B, 0x4D, 0xDC,
		0x8B, 0x11,
		0x89, 0x55, 0xB8,
		0x8B, 0x45, 0xDC,
		0x8B, 0x48, 0x04,
		0x89, 0x4D, 0xCC,
		0x8B, 0x55, 0xDC,
		0x8B, 0x42, 0x08,
		0x89, 0x45, 0xFC,
		0x8B, 0x4D, 0xFC,
		0x89, 0x4D, 0xC8,
		0x8B, 0x55, 0xC8,
		0x8B, 0x45, 0xFC,
		0x03, 0x42, 0x3C,
		0x89, 0x45, 0xE0,
		0x8B, 0x4D, 0xE0,
		0x8B, 0x55, 0xFC,
		0x2B, 0x51, 0x34,
		0x89, 0x55, 0xD4,
		0x0F, 0x84, 0xDC, 0x00, 0x00, 0x00,
		0xB8, 0x08, 0x00, 0x00, 0x00,
		0x6B, 0xC8, 0x05,
		0x8B, 0x55, 0xE0,
		0x8B, 0x44, 0x0A, 0x78,
		0x8B, 0x4C, 0x0A, 0x7C,
		0x89, 0x45, 0xA4,
		0x89, 0x4D, 0xA8,
		0x83, 0x7D, 0xA8, 0x00,
		0x0F, 0x84, 0xB9, 0x00, 0x00, 0x00,
		0x8B, 0x55, 0xFC,
		0x03, 0x55, 0xA4,
		0x89, 0x55, 0xF8,
		0x8B, 0x45, 0xF8,
		0x03, 0x45, 0xA8,
		0x89, 0x45, 0xC4,
		0x8B, 0x4D, 0xF8,
		0x3B, 0x4D, 0xC4,
		0x0F, 0x83, 0x9B, 0x00, 0x00, 0x00,
		0x8B, 0x55, 0xF8,
		0x83, 0x7A, 0x04, 0x00,
		0x0F, 0x84, 0x8E, 0x00, 0x00, 0x00,
		0x8B, 0x45, 0xF8,
		0x8B, 0x48, 0x04,
		0x83, 0xE9, 0x08,
		0xD1, 0xE9,
		0x89, 0x4D, 0xC0,
		0x8B, 0x55, 0xF8,
		0x83, 0xC2, 0x08,
		0x89, 0x55, 0xEC,
		0xC7, 0x45, 0xD8, 0x00, 0x00, 0x00, 0x00,
		0xEB, 0x12,
		0x8B, 0x45, 0xD8,
		0x83, 0xC0, 0x01,
		0x89, 0x45, 0xD8,
		0x8B, 0x4D, 0xEC,
		0x83, 0xC1, 0x02,
		0x89, 0x4D, 0xEC,
		0x8B, 0x55, 0xD8,
		0x3B, 0x55, 0xC0,
		0x74, 0x43,
		0x8B, 0x45, 0xEC,
		0x0F, 0xB7, 0x08,
		0xC1, 0xF9, 0x0C,
		0x83, 0xF9, 0x03,
		0x74, 0x02,
		0xEB, 0xD6,
		0x8B, 0x55, 0xF8,
		0x8B, 0x45, 0xFC,
		0x03, 0x02,
		0x8B, 0x4D, 0xEC,
		0x0F, 0xB7, 0x11,
		0x81, 0xE2, 0xFF, 0x0F, 0x00, 0x00,
		0x8B, 0x04, 0x10,
		0x03, 0x45, 0xD4,
		0x8B, 0x4D, 0xEC,
		0x0F, 0xB7, 0x11,
		0x81, 0xE2, 0xFF, 0x0F, 0x00, 0x00,
		0x8B, 0x4D, 0xF8,
		0x8B, 0x75, 0xFC,
		0x03, 0x31,
		0x89, 0x04, 0x16,
		0xEB, 0xA3,
		0x8B, 0x55, 0xF8,
		0x8B, 0x45, 0xF8,
		0x03, 0x42, 0x04,
		0x89, 0x45, 0xF8,
		0xE9, 0x59, 0xFF, 0xFF, 0xFF,
		0xB9, 0x08, 0x00, 0x00, 0x00,
		0xC1, 0xE1, 0x00,
		0x8B, 0x55, 0xE0,
		0x8B, 0x44, 0x0A, 0x78,
		0x8B, 0x4C, 0x0A, 0x7C,
		0x89, 0x45, 0x9C,
		0x89, 0x4D, 0xA0,
		0x83, 0x7D, 0xA0, 0x00,
		0x0F, 0x84, 0xC9, 0x00, 0x00, 0x00,
		0x8B, 0x55, 0xFC,
		0x03, 0x55, 0x9C,
		0x89, 0x55, 0xF0,
		0x83, 0x7D, 0xF0, 0x00,
		0x0F, 0x84, 0xB6, 0x00, 0x00, 0x00,
		0x8B, 0x45, 0xF0,
		0x83, 0x78, 0x0C, 0x00,
		0x0F, 0x84, 0xA9, 0x00, 0x00, 0x00,
		0x8B, 0x4D, 0xF0,
		0x8B, 0x55, 0xFC,
		0x03, 0x51, 0x0C,
		0x89, 0x55, 0xBC,
		0x8B, 0x45, 0xBC,
		0x50,
		0xFF, 0x55, 0xB8,
		0x89, 0x45, 0xD0,
		0x8B, 0x4D, 0xF0,
		0x8B, 0x55, 0xFC,
		0x03, 0x11,
		0x89, 0x55, 0xF4,
		0x8B, 0x45, 0xF0,
		0x8B, 0x4D, 0xFC,
		0x03, 0x48, 0x10,
		0x89, 0x4D, 0xE8,
		0x83, 0x7D, 0xF4, 0x00,
		0x75, 0x06,
		0x8B, 0x55, 0xE8,
		0x89, 0x55, 0xF4,
		0xEB, 0x12,
		0x8B, 0x45, 0xF4,
		0x83, 0xC0, 0x04,
		0x89, 0x45, 0xF4,
		0x8B, 0x4D, 0xE8,
		0x83, 0xC1, 0x04,
		0x89, 0x4D, 0xE8,
		0x8B, 0x55, 0xF4,
		0x83, 0x3A, 0x00,
		0x74, 0x46,
		0x8B, 0x45, 0xF4,
		0x8B, 0x08,
		0x81, 0xE1, 0x00, 0x00, 0x00, 0x80,
		0x74, 0x19,
		0x8B, 0x55, 0xF4,
		0x8B, 0x02,
		0x25, 0xFF, 0xFF, 0x00, 0x00,
		0x50,
		0x8B, 0x4D, 0xD0,
		0x51,
		0xFF, 0x55, 0xCC,
		0x8B, 0x55, 0xE8,
		0x89, 0x02,
		0xEB, 0x1E,
		0x8B, 0x45, 0xF4,
		0x8B, 0x4D, 0xFC,
		0x03, 0x08,
		0x89, 0x4D, 0xB4,
		0x8B, 0x55, 0xB4,
		0x83, 0xC2, 0x02,
		0x52,
		0x8B, 0x45, 0xD0,
		0x50,
		0xFF, 0x55, 0xCC,
		0x8B, 0x4D, 0xE8,
		0x89, 0x01,
		0xEB, 0xA0,
		0x8B, 0x55, 0xF0,
		0x83, 0xC2, 0x14,
		0x89, 0x55, 0xF0,
		0xE9, 0x40, 0xFF, 0xFF, 0xFF,
		0xB8, 0x08, 0x00, 0x00, 0x00,
		0xC1, 0xE0, 0x00,
		0x8B, 0x4D, 0xE0,
		0x8B, 0x54, 0x01, 0x78,
		0x8B, 0x44, 0x01, 0x7C,
		0x89, 0x55, 0x94,
		0x89, 0x45, 0x98,
		0x83, 0x7D, 0x98, 0x00,
		0x74, 0x3C,
		0x8B, 0x4D, 0xFC,
		0x03, 0x4D, 0x94,
		0x89, 0x4D, 0xB0,
		0x8B, 0x55, 0xB0,
		0x8B, 0x42, 0x0C,
		0x89, 0x45, 0xE4,
		0xEB, 0x09,
		0x8B, 0x4D, 0xE4,
		0x83, 0xC1, 0x04,
		0x89, 0x4D, 0xE4,
		0x83, 0x7D, 0xE4, 0x00,
		0x74, 0x19,
		0x8B, 0x55, 0xE4,
		0x83, 0x3A, 0x00,
		0x74, 0x11,
		0x6A, 0x00,
		0x6A, 0x01,
		0x8B, 0x45, 0xFC,
		0x50,
		0x8B, 0x4D, 0xE4,
		0x8B, 0x11,
		0xFF, 0xD2,
		0xEB, 0xD8,
		0x8B, 0x45, 0xE0,
		0x8B, 0x4D, 0xFC,
		0x03, 0x48, 0x28,
		0x89, 0x4D, 0xAC,
		0x6A, 0x00,
		0x6A, 0x01,
		0x8B, 0x55, 0xFC,
		0x52,
		0xFF, 0x55, 0xAC,
		0x85, 0xC0,
		0x75, 0x11,
		0x8B, 0x45, 0xDC,
		0xC7, 0x40, 0x0C, 0x02, 0x00, 0x00, 0x00,
		0xB8, 0x01, 0x00, 0x00, 0x00,
		0xEB, 0x0C,
		0x8B, 0x4D, 0xDC,
		0xC7, 0x41, 0x0C, 0x01, 0x00, 0x00, 0x00,
		0x33, 0xC0,
		0x5E,
		0x8B, 0xE5,
		0x5D,
		0xC3,
		0xCC, 0xCC, 0xCC, 0xCC,
		0x55,
		0x8B, 0xEC,
		0xB8, 0xD0, 0xB1, 0x40, 0x00,
		0x5D,
		0xC3,
};
#endif

static EShellCodeRet fncReadShellCodeStatus(Injector::CMemory* pMemory, LPVOID pParam) {
	TShellCodeParam scp = { 0 };
	scp.ret = EShellCodeRet::SHELLCODE_UNKOWN;

	while (scp.ret == EShellCodeRet::SHELLCODE_UNKOWN)
	{
		if(!pMemory->read(pParam, &scp, sizeof(TShellCodeParam)))
		{
			break;
		}

		Sleep(100);
	}

	return scp.ret;
}

bool Injector::Method::manualMapping(CMemory* pMemory, const char* targetModulePath, Executor::EMethod method, unsigned opt)
{
	bool ret = false;

	LPVOID pMappedModule = nullptr;

	LPVOID pTargetShellCodeParam = nullptr;
	LPVOID pTargetShellCode = nullptr;

	PIMAGE_DOS_HEADER header = nullptr;
	PIMAGE_NT_HEADERS ntheader = nullptr;

	TShellCodeParam scp = { 0 };
	scp.ret = EShellCodeRet::SHELLCODE_UNKOWN;

	FILE* f = nullptr;
	errno_t err = {};
	size_t fileSize = 0;

	BYTE* pModule = nullptr;

	char absolutePath[MAX_PATH] = { 0 };
	strcpy_s(absolutePath, MAX_PATH, targetModulePath);

	if (!Injector::helper::toAbsolutePath(absolutePath)) {
		Injector::logln("Failed to get absolute path");
		goto free;
	}

	err = fopen_s(&f, absolutePath, "rb");
	if (err != 0)
	{
		Injector::logln("fopen failed");
		goto free;
	}

	// read module
	{
		// set ptr to the end of file
		fseek(f, 0, SEEK_END);

		// get file size
		fileSize = ftell(f);

		// set ptr back to beginning of file
		fseek(f, 0, SEEK_SET);
	}

	// allocate space for module
	pModule = (BYTE*)malloc(fileSize * sizeof(BYTE) + 1);
	if (!pModule)
	{
		Injector::logln("malloc failed");
		goto free;
	}

	fread(reinterpret_cast<void*>(pModule), fileSize, 1, f);
	pModule[fileSize] = 0;

	header = reinterpret_cast<PIMAGE_DOS_HEADER>(pModule);
	ntheader = reinterpret_cast<PIMAGE_NT_HEADERS>(reinterpret_cast<tDWORD>(pModule) + header->e_lfanew);

	// Allocate & Write Module to target process
	{
		pMappedModule = pMemory->alloc(ntheader->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (!pMappedModule)
		{
			Injector::logln("VirtualAllocEx failed");
			goto free;
		}

		// write header first
		if(!pMemory->write(pMappedModule, pModule, Injector::helper::getPEHeaderSize(ntheader)))
		{
			Injector::logln("WriteProcessMemory failed");
			goto free;
		}

		// write module sections
		auto pSectionHeader = IMAGE_FIRST_SECTION(ntheader);
		for (WORD i = 0; i < ntheader->FileHeader.NumberOfSections; ++i, ++pSectionHeader)
		{
			if (pSectionHeader->SizeOfRawData != 0)
			{
				if(!pMemory->write(reinterpret_cast<LPVOID>(reinterpret_cast<tDWORD>(pMappedModule) + pSectionHeader->VirtualAddress), pModule + pSectionHeader->PointerToRawData, pSectionHeader->SizeOfRawData))
				{
					Injector::logln("WriteProcessMemory failed");
					goto free;
				}
			}
		}
	}

	// Allocate & Write Shellcode parameter
	{
		scp.pLoadLibraryA = LoadLibraryA;
		scp.pGetProcAddress = GetProcAddress;
		scp.pModuleAddress = pMappedModule;

		pTargetShellCodeParam = pMemory->alloc(sizeof(TShellCodeParam), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (!pTargetShellCodeParam)
		{
			Injector::logln("VirtualAllocEx failed");
			goto free;
		}

		if(!pMemory->write(pTargetShellCodeParam, &scp, sizeof(TShellCodeParam)))
		{
			Injector::logln("WriteProcessMemory failed");
			goto free;
		}
	}

	// Allocate & Write Shellcode
	{
		pTargetShellCode = pMemory->alloc(tInjector_ARRLEN(ShellCode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (!pTargetShellCode)
		{
			Injector::logln("VirtualAllocEx failed");
			goto free;
		}

		if(!pMemory->write(pTargetShellCode, ShellCode, tInjector_ARRLEN(ShellCode)))
		{
			Injector::logln("WriteProcessMemory failed");
			goto free;
		}
	}

	// execute shellcode
	if (!Injector::Executor::autoDetect(pMemory, method, pTargetShellCode, pTargetShellCodeParam, fncReadShellCodeStatus)) {
		goto free;
	}

	if (opt & OPT_ERASE_PE_HEADER)
	{
		unsigned char zero = 0;
		if(!pMemory->write(pMappedModule, &zero, Injector::helper::getPEHeaderSize(ntheader)))
		{
			Injector::logln("failed to remove pe header");
			goto free;
		}

		Injector::logln("removed pe header");
	}

	// success
	ret = true;

free:
	if (f) {
		fclose(f);
		f = nullptr;
	}

	if (pModule)
	{
		free(pModule);
		pModule = 0;
	}

	if (scp.ret != EShellCodeRet::SHELLCODE_SUCCESS)
	{
		pMemory->free(pMappedModule);
	}

	pMemory->free(pTargetShellCodeParam);
	pMemory->free(pTargetShellCode);

	return ret;
}